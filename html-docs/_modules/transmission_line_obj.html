


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>transmission_line_obj &mdash; Ludwik 0.0.1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/jquery.fancybox.min.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/glpi.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="Ludwik 0.0.1 documentation" href="../index.html"/>
        <link rel="up" title="Module code" href="index.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Ludwik
          

          
          </a>

          
            
              <div class="version">
                0.0.1

                
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../transmission_line.html">Transmission line</a></li>
<li class="toctree-l1"><a class="reference internal" href="../transmission_line_obj.html">Optical elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rays.html">Rays</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../interpolation_tools.html">Interpolation tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../behappy.html">HITRAN database access</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input_gen.html">Generating of input spectrum</a></li>
<li class="toctree-l1"><a class="reference internal" href="../settings.html">Settings</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Ludwik</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>transmission_line_obj</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for transmission_line_obj</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Author: Michał Porębski</span>
<span class="sd">Transmission line is made of different components, in this module they are implemented:</span>

<span class="sd">    - Vacuum</span>
<span class="sd">    - Air</span>
<span class="sd">    - FlatMirror</span>
<span class="sd">    - ParabolicMirror</span>
<span class="sd">    - Window</span>
<span class="sd">    - Spherical lens</span>
<span class="sd">    - Screen</span>
<span class="sd">    - Prism</span>
<span class="sd">        - PrismZnSe</span>

<span class="sd">All components inherit from TransmissionObject class. New components can be easily added by overriding the methods of</span>
<span class="sd">parent class. Main assumptions:</span>

<span class="sd">    - angle is angle of rotation of element</span>
<span class="sd">    - default paths to characteristics are defined in settings file</span>
<span class="sd">    - lengths are in millimeters</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># from transmission_line import TransmissionLine, Ray</span>
<span class="kn">import</span> <span class="nn">tools_functions</span> <span class="k">as</span> <span class="nn">tools</span>
<span class="kn">import</span> <span class="nn">refle_interpolation</span> <span class="k">as</span> <span class="nn">interpol</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.transform</span> <span class="k">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">R</span>
<span class="kn">import</span> <span class="nn">settings</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="k">as</span> <span class="nn">pat</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d.art3d</span> <span class="k">import</span> <span class="n">Poly3DCollection</span>
<span class="kn">import</span> <span class="nn">behapi</span>

<span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">longdouble</span><span class="p">(</span>
    <span class="mf">3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679</span><span class="p">)</span>


<div class="viewcode-block" id="TransmissionObject"><a class="viewcode-back" href="../transmission_line_obj.html#transmission_line_obj.TransmissionObject">[docs]</a><span class="k">class</span> <span class="nc">TransmissionObject</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parent class of all transmission objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>

        <span class="c1"># length: float = 0,</span>
        <span class="c1"># angle: float = 0,</span>
        <span class="c1"># normal_vector: np.ndarray = np.array([0, 0, 0]),</span>
        <span class="c1"># position: np.ndarray = np.array([0, 0, 0]),</span>
        <span class="c1"># coordinates: np.ndarray = np.array([0, 0, 0]),</span>
        <span class="c1"># distance_from_previous: float = 0,</span>
        <span class="c1"># acceptance_angle: float = 0,</span>
        <span class="c1"># tran_char_interp: callable = lambda: True,</span>
        <span class="c1"># diameter: float = 1,</span>
        <span class="n">default_vals</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;length&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;distance_from_previous&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;acceptance_angle&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;angle&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;position&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
            <span class="s2">&quot;normal_vector&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
            <span class="s2">&quot;coordinates&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
            <span class="s2">&quot;tran_char_interp&quot;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s2">&quot;diameter&quot;</span><span class="p">:</span> <span class="mi">1</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">default_vals</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;angle&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normal_vector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;normal_vector&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;coordinates&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance_from_previous</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;distance_from_previous&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_angle</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;acceptance_angle&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tran_char_interp</span><span class="p">:</span> <span class="n">callable</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;tran_char_interp&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;diameter&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># super().__init__(kwargs)</span>

    <span class="c1"># calculates acceptance angle - full angle</span>
<div class="viewcode-block" id="TransmissionObject.calculate_acceptance_angle"><a class="viewcode-back" href="../transmission_line_obj.html#transmission_line_obj.TransmissionObject.calculate_acceptance_angle">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_acceptance_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_min_max</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates acceptance angle for obj, can return minimal and maximal angle if needed</span>

<span class="sd">        :param bool return_min_max: if True than returns min and max angles</span>
<span class="sd">        :return: (float, float): (min_angle, max_angle)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_from_previous</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Distance from previous mirror is not defined&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Diameter is not defined &quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Position is not defined &quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Coordinates are not defined &quot;</span><span class="p">)</span>

        <span class="n">p2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">p3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">p1x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_from_previous</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">p1y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_from_previous</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">min_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">((</span><span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">p1y</span><span class="p">),</span> <span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">p1x</span><span class="p">))</span>
        <span class="n">max_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">((</span><span class="n">p3</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">p1y</span><span class="p">),</span> <span class="p">(</span><span class="n">p3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">p1x</span><span class="p">))</span>
        <span class="c1"># min_angle, max_angle = tools.calculate_acceptance_angles(</span>
        <span class="c1">#     p1x, p1y, p2[0], p2[1], p3[0], p3[1])</span>
        <span class="n">acceptance_angle</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">max_angle</span><span class="p">)</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">min_angle</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="c1"># acceptance_angle = np.arctan(self.diameter / 2 / self.distance_from_previous)</span>
        <span class="c1"># if is smaller than zero then shift it</span>
        <span class="c1"># if acceptance_angle &lt; 0:</span>
        <span class="c1">#     acceptance_angle += np.pi * 2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acceptance_angle</span> <span class="o">=</span> <span class="n">acceptance_angle</span>
        <span class="k">if</span> <span class="n">return_min_max</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">min_angle</span><span class="p">,</span> <span class="n">max_angle</span></div>

<div class="viewcode-block" id="TransmissionObject.add_normal_vector_to_mirror"><a class="viewcode-back" href="../transmission_line_obj.html#transmission_line_obj.TransmissionObject.add_normal_vector_to_mirror">[docs]</a>    <span class="k">def</span> <span class="nf">add_normal_vector_to_mirror</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds normal vector to object, in key &quot;normal_vector&quot;</span>

<span class="sd">        :return: none,</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_component</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">y_component</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># distance = np.sqrt(x_component**2 + y_component**2)</span>
        <span class="c1"># if distance != 0:</span>
        <span class="c1">#     x_component /= distance</span>
        <span class="c1">#     y_component /= distance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normal_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_component</span><span class="p">,</span> <span class="n">y_component</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="TransmissionObject.load_spectrum_characteristic"><a class="viewcode-back" href="../transmission_line_obj.html#transmission_line_obj.TransmissionObject.load_spectrum_characteristic">[docs]</a>    <span class="k">def</span> <span class="nf">load_spectrum_characteristic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads characteristics in form of function in which we can pass values to get</span>

<span class="sd">        :param string path: if different than &quot;default&quot; then it is used as path to read characteristics</span>
<span class="sd">        :return: none</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tran_char_interp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">val</span><span class="p">:</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="TransmissionObject.transform_energies_vectorized"><a class="viewcode-back" href="../transmission_line_obj.html#transmission_line_obj.TransmissionObject.transform_energies_vectorized">[docs]</a>    <span class="k">def</span> <span class="nf">transform_energies_vectorized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rays</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transforms energies of rays with objects reflectance/transmission characteristic</span>

<span class="sd">        :param Rays rays:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">energies</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tran_char_interp</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">)</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">transformed_energies</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tran_char_interp</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">spectrum</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="TransmissionObject.get_transformation"><a class="viewcode-back" href="../transmission_line_obj.html#transmission_line_obj.TransmissionObject.get_transformation">[docs]</a>    <span class="k">def</span> <span class="nf">get_transformation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">total_atmosphere_length</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns callable spectrum transformation, air edit total_atmosphere_length by adding the length of itself,</span>
<span class="sd">        total_atmosphere_length have to be list with fist element containing current length</span>

<span class="sd">        :param list total_atmosphere_length:</span>
<span class="sd">        :return: (callable) transmission_characteristics</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tran_char_interp</span></div>

<div class="viewcode-block" id="TransmissionObject.draw"><a class="viewcode-back" href="../transmission_line_obj.html#transmission_line_obj.TransmissionObject.draw">[docs]</a>    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">plot_type</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draws object on canvas ax, changes current_angle, x and y for construction whole transmission line</span>

<span class="sd">        :param float current_angle:</span>
<span class="sd">        :param float current_x:</span>
<span class="sd">        :param float current_y:</span>
<span class="sd">        :param plt.axis ax:</span>
<span class="sd">        :param string plot_type: 3d or 2d depends on the need</span>
<span class="sd">        :param bool plot: boolean flag if you want to plot sth or not</span>
<span class="sd">        :return: (float, float, float): current_angle, current_x, current_y</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span></div>

<div class="viewcode-block" id="TransmissionObject.set_distances_and_characteristics"><a class="viewcode-back" href="../transmission_line_obj.html#transmission_line_obj.TransmissionObject.set_distances_and_characteristics">[docs]</a>    <span class="k">def</span> <span class="nf">set_distances_and_characteristics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">previous_obj</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function for setting distances from previous element, used for calculating acceptance angles and loading</span>
<span class="sd">        spectrum characteristics</span>

<span class="sd">        :param TransmissionObject previous_obj: previous object</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_from_previous</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">previous_obj</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">distance_from_previous</span> <span class="o">=</span> <span class="n">previous_obj</span><span class="o">.</span><span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_spectrum_characteristic</span><span class="p">()</span></div>

<div class="viewcode-block" id="TransmissionObject.construct_obj"><a class="viewcode-back" href="../transmission_line_obj.html#transmission_line_obj.TransmissionObject.construct_obj">[docs]</a>    <span class="k">def</span> <span class="nf">construct_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span><span class="p">,</span> <span class="n">current_z</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct object, edits obj.coordinates, obj.position, obj.angle, obj.normal_vector, default is for</span>
<span class="sd">        vacuum</span>

<span class="sd">        :param (float) current_angle:</span>
<span class="sd">        :param (float) current_x:</span>
<span class="sd">        :param (float) current_y:</span>
<span class="sd">        :param (float) current_z:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_spectrum_characteristic</span><span class="p">()</span>
        <span class="n">current_x</span> <span class="o">=</span> <span class="n">current_x</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">current_angle</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="n">current_y</span> <span class="o">=</span> <span class="n">current_y</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">current_angle</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="k">return</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span></div>

<div class="viewcode-block" id="TransmissionObject.interact_with_obj_vectorized"><a class="viewcode-back" href="../transmission_line_obj.html#transmission_line_obj.TransmissionObject.interact_with_obj_vectorized">[docs]</a>    <span class="k">def</span> <span class="nf">interact_with_obj_vectorized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rays</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Geometrical interaction with Rays obj, returns truth table which rays fit and which doesn&#39;t, edits</span>
<span class="sd">        some parameters of Rays obj</span>

<span class="sd">            - position,</span>
<span class="sd">            - angles_xy,</span>
<span class="sd">            - angles_xz,</span>

<span class="sd">        :param Rays rays: Rays obj</span>
<span class="sd">        :return: (boolean np.array) np.array of length len(rays.positions)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">positions</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span></div>

<div class="viewcode-block" id="TransmissionObject.plot_cross_section_on_obj"><a class="viewcode-back" href="../transmission_line_obj.html#transmission_line_obj.TransmissionObject.plot_cross_section_on_obj">[docs]</a>    <span class="k">def</span> <span class="nf">plot_cross_section_on_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot obj cross section, canvas on input</span>

<span class="sd">        :param (plt.axis) ax:</span>
<span class="sd">        :return: (plt.axis) ax</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ax</span></div>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">f</span><span class="s2">&quot;{type(self).__name__}({super().__repr__()})&quot;</span></div>


<div class="viewcode-block" id="FlatMirror"><a class="viewcode-back" href="../transmission_line_obj.html#transmission_line_obj.FlatMirror">[docs]</a><span class="k">class</span> <span class="nc">FlatMirror</span><span class="p">(</span><span class="n">TransmissionObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Flat mirror,</span>
<span class="sd">        -diameter</span>

<span class="sd">        -angle - does not have relative angle, angle defines the rotation from zero rotation, in angle = 0 it is</span>
<span class="sd">        perpendicular to X axis</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;FlatMirror&quot;</span>

    <span class="k">def</span> <span class="nf">load_spectrum_characteristic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">path</span> <span class="o">==</span> <span class="s2">&quot;default&quot;</span><span class="p">:</span>
            <span class="n">char_data</span> <span class="o">=</span> <span class="n">interpol</span><span class="o">.</span><span class="n">read_characteristics</span><span class="p">(</span><span class="n">settings</span><span class="o">.</span><span class="n">default_path_flat_mirror_char</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">char_data</span> <span class="o">=</span> <span class="n">interpol</span><span class="o">.</span><span class="n">read_characteristics</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">char_data</span> <span class="o">=</span> <span class="n">interpol</span><span class="o">.</span><span class="n">normalize_characteristics</span><span class="p">(</span><span class="n">char_data</span><span class="p">,</span> <span class="n">shift_maximum</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tran_char_interp</span> <span class="o">=</span> <span class="n">interpol</span><span class="o">.</span><span class="n">linear_interpolation</span><span class="p">(</span><span class="n">char_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">plot_type</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># construct rectangle without rotation, z coordinate - 0</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                           <span class="p">[</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                           <span class="p">[</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                           <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>

        <span class="c1"># rotate_angle = actual_angle + obj.angle/2      # if the angle is relative to the beam</span>
        <span class="n">rotate_angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span>  <span class="c1"># if the angle is absolute</span>
        <span class="c1"># firstly translate the center of rotation</span>
        <span class="c1"># coords[:, 0] -= current_x</span>
        <span class="c1"># coords[:, 1] -= current_y</span>
        <span class="k">if</span> <span class="n">plot_type</span> <span class="o">==</span> <span class="s1">&#39;3d&#39;</span> <span class="ow">and</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">num_of_points</span> <span class="o">=</span> <span class="mi">20</span>
            <span class="n">coords3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_of_points</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">3</span><span class="p">])</span>
            <span class="c1"># create points in z dimension</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">angle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">num_of_points</span><span class="p">)):</span>
                <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="n">angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>  <span class="c1"># rotation matrix</span>
                <span class="n">coords3d</span><span class="p">[</span><span class="n">index</span> <span class="o">*</span> <span class="mi">4</span><span class="p">:</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
            <span class="n">coords3d</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">=</span> <span class="n">coords3d</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
            <span class="c1"># rotate along z axis</span>
            <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="n">rotate_angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>  <span class="c1"># rotation matrix</span>
            <span class="n">coords3d</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">coords3d</span><span class="p">)</span>
            <span class="c1"># translate back to the location</span>
            <span class="n">coords3d</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_x</span>
            <span class="n">coords3d</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_y</span>

            <span class="n">bottom</span> <span class="o">=</span> <span class="n">coords3d</span><span class="p">[</span><span class="n">coords3d</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">coords3d</span><span class="p">[</span><span class="n">coords3d</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
            <span class="c1"># ax.plot_surface(np.array((coords3d[::4, 0], coords3d[3::4, 0])),</span>
            <span class="c1">#             np.array((coords3d[::4, 1], coords3d[3::4, 1])),</span>
            <span class="c1">#             np.array((coords3d[::4, 2], coords3d[3::4, 2])), color=&#39;yellow&#39;)</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">plot_trisurf</span><span class="p">(</span><span class="n">bottom</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">bottom</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">bottom</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;yellow&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot_trisurf</span><span class="p">(</span><span class="n">top</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">top</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">top</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;yellow&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="n">rotate_angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>  <span class="c1"># rotation matrix</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
            <span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_x</span>
            <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_y</span>
            <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;g&#39;</span><span class="p">)</span>
        <span class="n">direction_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">current_angle</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">current_angle</span><span class="p">),</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">reflected_vector</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">reflect_vector_from_plane</span><span class="p">(</span><span class="n">direction_vector</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal_vector</span><span class="p">)</span>
        <span class="n">current_angle</span><span class="p">,</span> <span class="n">xz</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">get_xyxzangles_from_vector</span><span class="p">(</span><span class="n">reflected_vector</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span>

    <span class="k">def</span> <span class="nf">construct_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span><span class="p">,</span> <span class="n">current_z</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_normal_vector_to_mirror</span><span class="p">()</span>  <span class="c1"># add normal vector describing the plane of mirror</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_spectrum_characteristic</span><span class="p">()</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                           <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                           <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                           <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
        <span class="c1"># rotate_angle = actual_angle + obj.angle/2      # if the angle is relative to the beam</span>
        <span class="n">rotate_angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span>
        <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="n">rotate_angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>  <span class="c1"># rotation matrix</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_x</span>
        <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="n">coords</span>
        <span class="c1"># save position of mirror</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span><span class="p">,</span> <span class="n">current_z</span><span class="p">])</span>
        <span class="c1"># calculate beam angle</span>
        <span class="c1"># current_angle = np.pi - current_angle - 2 * self.angle</span>
        <span class="n">direction_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">current_angle</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">current_angle</span><span class="p">),</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">reflected_vector</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">reflect_vector_from_plane</span><span class="p">(</span><span class="n">direction_vector</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal_vector</span><span class="p">)</span>
        <span class="n">current_angle</span><span class="p">,</span> <span class="n">xz</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">get_xyxzangles_from_vector</span><span class="p">(</span><span class="n">reflected_vector</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span>

    <span class="k">def</span> <span class="nf">interact_with_obj_vectorized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rays</span><span class="p">):</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">p3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># min_angle, max_angle = tools.calculate_acceptance_angles_vectorized(</span>
        <span class="c1">#     rays.positions[:, 0], rays.positions[:, 1], p2[0], p2[1], p3[0], p3[1])</span>
        <span class="c1"># fit_in = tools.does_fit_in_acceptance_angle_vectorized(rays.anglesXY, min_angle, max_angle)</span>
        <span class="c1"># if hit</span>

        <span class="n">plane_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span>
        <span class="n">plane_normal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal_vector</span>
        <span class="c1"># calculate ray direction vector</span>
        <span class="n">ray_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">anglesXY</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">rays</span><span class="o">.</span><span class="n">anglesXZ</span><span class="p">)</span>
        <span class="n">ray_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">anglesXY</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">rays</span><span class="o">.</span><span class="n">anglesXZ</span><span class="p">)</span>
        <span class="n">ray_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">rays</span><span class="o">.</span><span class="n">anglesXZ</span><span class="p">)</span>

        <span class="c1"># ray_direction = np.array([ray_x, ray_y, ray_z]</span>
        <span class="n">ray_direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ray_x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">ray_direction</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ray_x</span>
        <span class="n">ray_direction</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ray_y</span>
        <span class="n">ray_direction</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ray_z</span>
        <span class="n">rays_point</span> <span class="o">=</span> <span class="n">rays</span><span class="o">.</span><span class="n">positions</span>

        <span class="c1"># calculate intersection point</span>
        <span class="sd">&quot;&quot;&quot;In future can be checked if inside the mirror, just to be sure xD&quot;&quot;&quot;</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">line_plane_collision_vectorized</span><span class="p">(</span><span class="n">plane_normal</span><span class="p">,</span> <span class="n">plane_point</span><span class="p">,</span> <span class="n">ray_direction</span><span class="p">,</span> <span class="n">rays_point</span><span class="p">)</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">rays</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">plane_point</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                            <span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">plane_point</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                            <span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">plane_point</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">reflected_vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">reflected_vectors</span><span class="p">[</span><span class="n">distances</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">reflect_array_of_vectors_from_plane</span><span class="p">(</span>
            <span class="n">ray_direction</span><span class="p">[</span><span class="n">distances</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal_vector</span><span class="p">)</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">anglesXY</span><span class="p">,</span> <span class="n">rays</span><span class="o">.</span><span class="n">anglesXZ</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">get_xyxzangles_from_vectors</span><span class="p">(</span><span class="n">reflected_vectors</span><span class="p">)</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">anglesXY</span><span class="p">[</span><span class="n">rays</span><span class="o">.</span><span class="n">anglesXY</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">anglesXZ</span><span class="p">[</span><span class="n">rays</span><span class="o">.</span><span class="n">anglesXZ</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="c1"># return np.logical_and(fit_in, distances &lt;= self.diameter / 2)</span>
        <span class="k">return</span> <span class="n">distances</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">plot_cross_section_on_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
        <span class="c1"># mirror = plt.Circle((0, 0), self.diameter / 2, color=(0.1, 0.1, 0.9, 0.3))</span>
        <span class="c1"># mirror = pat.Ellipse((0, 0), self.diameter * np.cos(self.angle), self.diameter,</span>
        <span class="c1">#                      color=(0.1, 0.1, 0.9, 0.3))</span>
        <span class="n">mirror</span> <span class="o">=</span> <span class="n">pat</span><span class="o">.</span><span class="n">Ellipse</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">mirror</span><span class="p">)</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">10</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ymin</span><span class="o">=-</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="n">xmax</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">((</span><span class="o">-</span><span class="n">xmax</span><span class="p">,</span> <span class="n">xmax</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="SphericalLens"><a class="viewcode-back" href="../transmission_line_obj.html#transmission_line_obj.SphericalLens">[docs]</a><span class="k">class</span> <span class="nc">SphericalLens</span><span class="p">(</span><span class="n">TransmissionObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Spherical lens:</span>
<span class="sd">        not sure if works properly, needs checking, works like ideal lens, can be turned on the correct intersections,</span>
<span class="sd">        now have intersection with plane, intersection with circle is implemented and tested</span>
<span class="sd">        -focal_length - focal length of lens</span>

<span class="sd">        -diameter</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">focal_length</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">relative_angle</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="s2">&quot;Spherical_Mirror&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">focal_length</span> <span class="o">=</span> <span class="n">focal_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relative_angle</span> <span class="o">=</span> <span class="n">relative_angle</span>
        <span class="c1"># super(TransmissionObject, self).__init__(kwargs)</span>

    <span class="k">def</span> <span class="nf">load_spectrum_characteristic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">path</span> <span class="o">==</span> <span class="s2">&quot;default&quot;</span><span class="p">:</span>
            <span class="n">char_data</span> <span class="o">=</span> <span class="n">interpol</span><span class="o">.</span><span class="n">read_characteristics</span><span class="p">(</span><span class="n">settings</span><span class="o">.</span><span class="n">default_path_flat_mirror_char</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">char_data</span> <span class="o">=</span> <span class="n">interpol</span><span class="o">.</span><span class="n">read_characteristics</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">char_data</span> <span class="o">=</span> <span class="n">interpol</span><span class="o">.</span><span class="n">normalize_characteristics</span><span class="p">(</span><span class="n">char_data</span><span class="p">,</span> <span class="n">shift_maximum</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tran_char_interp</span> <span class="o">=</span> <span class="n">interpol</span><span class="o">.</span><span class="n">linear_interpolation</span><span class="p">(</span><span class="n">char_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">construct_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span><span class="p">,</span> <span class="n">current_z</span><span class="p">):</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                           <span class="p">[</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_angle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">construction_angle</span> <span class="o">=</span> <span class="n">current_angle</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_angle</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">=</span> <span class="n">current_angle</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_angle</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">construction_angle</span> <span class="o">=</span> <span class="n">current_angle</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">=</span> <span class="n">current_angle</span>
        <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">construction_angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>  <span class="c1"># rotation matrix</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_x</span>
        <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="n">coords</span>
        <span class="c1"># save position of mirror</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span><span class="p">,</span> <span class="n">current_z</span><span class="p">])</span>
        <span class="c1"># calculate beam angle</span>
        <span class="c1"># current_angle = np.pi - current_angle - 2 * self.angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">focus_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">focal_length</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">focal_length</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">construction_point</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">focus_point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_normal_vector_to_mirror</span><span class="p">()</span>
        <span class="c1"># direction_vector = np.array([np.cos(current_angle), np.sin(current_angle), 0])</span>
        <span class="c1"># reflected_vector = tools.reflect_vector_from_plane(direction_vector, self.normal_vector)</span>
        <span class="c1"># current_angle, xz = tools.get_xyxzangles_from_vector(reflected_vector)</span>

        <span class="k">return</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span>

    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">plot_type</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">rotate_angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">construction_angle</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">focal_length</span>
        <span class="n">y_offset</span> <span class="o">=</span> <span class="n">radius</span>
        <span class="c1"># x_offset = np.sqrt(radius ** 2 - (obj.diameter / 2) ** 2)</span>
        <span class="k">for</span> <span class="n">temp_x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
            <span class="n">temp_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">radius</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">temp_x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">temp_y</span> <span class="o">-=</span> <span class="n">y_offset</span>
            <span class="k">if</span> <span class="n">temp_x</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(([[</span><span class="n">temp_x</span><span class="p">,</span> <span class="n">temp_y</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="p">[[</span><span class="n">temp_x</span><span class="p">,</span> <span class="n">temp_y</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_type</span> <span class="o">==</span> <span class="s1">&#39;3d&#39;</span> <span class="ow">and</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">num_of_points</span> <span class="o">=</span> <span class="mi">20</span>
            <span class="n">num_of_coordinates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
            <span class="n">coords3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">num_of_coordinates</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_of_points</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">3</span><span class="p">])</span>
            <span class="c1"># create points in z dimension</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">angle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">num_of_points</span><span class="p">)):</span>
                <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="n">angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>  <span class="c1"># rotation matrix</span>
                <span class="n">coords3d</span><span class="p">[</span><span class="n">index</span> <span class="o">*</span> <span class="n">num_of_coordinates</span><span class="p">:</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_of_coordinates</span><span class="p">]</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
            <span class="n">coords3d</span><span class="p">[</span><span class="o">-</span><span class="n">num_of_coordinates</span><span class="p">:]</span> <span class="o">=</span> <span class="n">coords3d</span><span class="p">[:</span><span class="n">num_of_coordinates</span><span class="p">]</span>
            <span class="c1"># rotate along z axis</span>
            <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="n">rotate_angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>  <span class="c1"># rotation matrix</span>
            <span class="n">coords3d</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">coords3d</span><span class="p">)</span>
            <span class="c1"># translate back to the location</span>
            <span class="n">coords3d</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_x</span>
            <span class="n">coords3d</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_y</span>

            <span class="n">bottom</span> <span class="o">=</span> <span class="n">coords3d</span><span class="p">[</span><span class="n">coords3d</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">coords3d</span><span class="p">[</span><span class="n">coords3d</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot_trisurf</span><span class="p">(</span><span class="n">bottom</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">bottom</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">bottom</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot_trisurf</span><span class="p">(</span><span class="n">top</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">top</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">top</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="n">rotate_angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>  <span class="c1"># rotation matrix</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
            <span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_x</span>
            <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_y</span>
            <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;g&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">focus_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">focus_point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>

        <span class="c1"># direction_vector = np.array([np.cos(current_angle), np.sin(current_angle), 0])</span>
        <span class="c1"># reflected_vector = tools.reflect_vector_from_plane(direction_vector, self.normal_vector)</span>
        <span class="c1"># current_angle, xz = tools.get_xyxzangles_from_vector(reflected_vector)</span>
        <span class="k">return</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span>

    <span class="k">def</span> <span class="nf">interact_with_obj_vectorized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rays</span><span class="p">):</span>
        <span class="c1"># p1 = rays.positions</span>
        <span class="c1"># distance_to_second_point = self.distance_from_previous + 3 * self.focal_length</span>
        <span class="c1"># p1_x = p1[:, 0]</span>
        <span class="c1"># p1_y = p1[:, 1]</span>
        <span class="c1"># p1_z = p1[:, 2]</span>
        <span class="c1"># p2_x = rays.positions[:, 0] + np.cos(rays.anglesXY) * np.sin(</span>
        <span class="c1">#     np.pi / 2 - rays.anglesXZ) * distance_to_second_point</span>
        <span class="c1">#</span>
        <span class="c1"># p2_y = rays.positions[:, 1] + np.sin(rays.anglesXY) * np.sin(</span>
        <span class="c1">#     np.pi / 2 - rays.anglesXZ) * distance_to_second_point</span>
        <span class="c1"># p2_z = rays.positions[:, 2] + np.cos(np.pi / 2 - rays.anglesXZ) * distance_to_second_point</span>
        <span class="c1"># p3 = self.focus_point</span>
        <span class="c1"># a = (p2_x - p1_x) ** 2 + (p2_y - p1_y) ** 2 + (p2_z - p1_z) ** 2</span>
        <span class="c1"># b = 2 * ((p2_x - p1_x) * (p1_x - p3[0]) + (p2_y - p1_y) * (p1_y - p3[1]) + (p2_z - p1_z) *</span>
        <span class="c1">#          (p1_z - p3[2]))</span>
        <span class="c1"># c = p3[0] ** 2 + p3[1] ** 2 + p3[2] ** 2 + p1_x ** 2 + p1_y ** 2 + p1_z ** 2 - \</span>
        <span class="c1">#     2 * (p3[0] * p1_x + p3[1] * p1_y + p3[2] * p1_z) - self.focal_length ** 2</span>
        <span class="c1"># delta = b ** 2 - 4 * a * c</span>
        <span class="c1"># delta[delta &lt; 0] = 0</span>
        <span class="c1"># u1 = (-b + np.sqrt(delta)) / (2 * a)</span>
        <span class="c1"># u2 = (-b - np.sqrt(delta)) / (2 * a)</span>
        <span class="c1"># xu1 = p1_x + u1 * (p2_x - p1_x)</span>
        <span class="c1"># yu1 = p1_y + u1 * (p2_y - p1_y)</span>
        <span class="c1"># zu1 = p1_z + u1 * (p2_z - p1_z)</span>
        <span class="c1"># xu2 = p1_x + u2 * (p2_x - p1_x)</span>
        <span class="c1"># yu2 = p1_y + u2 * (p2_y - p1_y)</span>
        <span class="c1"># zu2 = p1_z + u2 * (p2_z - p1_z)</span>
        <span class="c1"># mask = ((xu1 - p1_x) ** 2 + (yu1 - p1_y) ** 2 + (zu1 - p1_z) ** 2) &gt; \</span>
        <span class="c1">#        ((xu2 - p1_x) ** 2 + (yu2 - p1_y) ** 2 + (zu2 - p1_z) ** 2)</span>
        <span class="c1"># intersection_points = np.column_stack((xu1, yu1, zu1))</span>
        <span class="c1"># # print(delta)</span>
        <span class="c1"># intersection_points[mask, :] = np.column_stack((xu2, yu2, zu2))[mask, :]</span>

        <span class="n">intersection_points</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">line_plane_collision_vectorized</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">normal_vector</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">anglesXY</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">rays</span><span class="o">.</span><span class="n">anglesXZ</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">anglesXY</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">rays</span><span class="o">.</span><span class="n">anglesXZ</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">rays</span><span class="o">.</span><span class="n">anglesXZ</span><span class="p">)])</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">rays</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span>

        <span class="c1"># calculate angles from distances:</span>
        <span class="n">ps1</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">lines_intersection</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">intersection_points</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">focus_point</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">side_of_line</span><span class="p">(</span><span class="n">intersection_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">focus_point</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">ps1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">ps1</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">signation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">ps1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span> <span class="n">ps1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">))</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">get_euclidean_distance</span><span class="p">(</span><span class="n">ps1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ps1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">focal_length</span>
        <span class="n">s2</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">focal_length</span> <span class="o">*</span> <span class="n">s1</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">focal_length</span><span class="p">)</span>
        <span class="c1"># s2[mask] = 1/(1 / self.focal_length - 1 / s1[mask])</span>
        <span class="n">h</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">tools</span><span class="o">.</span><span class="n">get_euclidean_distance</span><span class="p">(</span><span class="n">intersection_points</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[:</span><span class="mi">2</span><span class="p">]))</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">anglesXY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">+</span> <span class="n">signation</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">h</span> <span class="o">/</span> <span class="n">s2</span><span class="p">)</span>

        <span class="c1"># now, xz angles:</span>
        <span class="n">ps1</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">lines_intersection</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span>
                                       <span class="n">rays</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span> <span class="o">+</span>
                                       <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">rays</span><span class="o">.</span><span class="n">anglesXZ</span><span class="p">),</span>
                                                 <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">rays</span><span class="o">.</span><span class="n">anglesXZ</span><span class="p">)])</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span>
                                       <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
        <span class="n">signation</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">intersection_points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">ps1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span> <span class="n">ps1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">))</span>

        <span class="n">s1</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">get_euclidean_distance</span><span class="p">(</span><span class="n">ps1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ps1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">focal_length</span>
        <span class="c1"># s2[mask] = 1/(1 / self.focal_length - 1 / s1[mask])</span>
        <span class="n">s2</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">focal_length</span> <span class="o">*</span> <span class="n">s1</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">focal_length</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">intersection_points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">anglesXZ</span> <span class="o">=</span> <span class="n">signation</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">h</span> <span class="o">/</span> <span class="n">s2</span><span class="p">))</span>
        <span class="c1"># angles_xz = np.arctan2(self.focus_point[2] - intersection_points[:, 2],</span>
        <span class="c1">#                        tools.get_euclidean_distance(self.focus_point[:2], intersection_points[:, :2]))</span>

        <span class="c1"># rays.anglesXZ[s1 == float(&quot;inf&quot;)] = angles_xz[s1 == float(&quot;inf&quot;)]</span>

        <span class="c1"># plt.figure()</span>
        <span class="c1"># plt.plot(rays.anglesXY)</span>
        <span class="c1"># plt.show()</span>
        <span class="n">distancexy</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">get_euclidean_distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">intersection_points</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">distancexz</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">get_euclidean_distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="n">intersection_points</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
        <span class="c1"># rays.anglesXZ[rays.anglesXZ &lt; 0] += np.pi</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">anglesXY</span><span class="p">[</span><span class="n">rays</span><span class="o">.</span><span class="n">anglesXY</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">intersection_points</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">distancexy</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="p">,</span> <span class="n">distancexz</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_normal_vector_to_mirror</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">x_component</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="p">)</span>
        <span class="n">y_component</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normal_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_component</span><span class="p">,</span> <span class="n">y_component</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="Vacuum"><a class="viewcode-back" href="../transmission_line_obj.html#transmission_line_obj.Vacuum">[docs]</a><span class="k">class</span> <span class="nc">Vacuum</span><span class="p">(</span><span class="n">TransmissionObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Vacuum is vacuum, not very complicated</span>
<span class="sd">        -length - length of object in milimiters</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="s2">&quot;Vacuum&quot;</span>

    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">plot_type</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">coord_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">current_x</span><span class="p">]</span>
        <span class="n">current_x</span> <span class="o">=</span> <span class="n">current_x</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">current_angle</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="n">coord_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_x</span><span class="p">)</span>
        <span class="n">coord_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">current_y</span><span class="p">]</span>
        <span class="n">current_y</span> <span class="o">=</span> <span class="n">current_y</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">current_angle</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="n">coord_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">coord_x</span><span class="p">,</span> <span class="n">coord_y</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span></div>


<span class="k">class</span> <span class="nc">Screen</span><span class="p">(</span><span class="n">TransmissionObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Detector screen:</span>
<span class="sd">        -relative_angle_deg - In default is perpendicular, can be rotated, in radians</span>

<span class="sd">        -relative_angle - relative rotation in degrees</span>

<span class="sd">        -height - height of pixels in milimeters</span>

<span class="sd">        -diameter - width of sensor</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">relative_angle_deg</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">relative_angle</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">height</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="s2">&quot;Screen&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span>
        <span class="k">if</span> <span class="n">relative_angle_deg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relative_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">relative_angle_deg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relative_angle</span> <span class="o">=</span> <span class="n">relative_angle</span>

    <span class="k">def</span> <span class="nf">construct_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span><span class="p">,</span> <span class="n">current_z</span><span class="p">):</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">],</span>
                           <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">],</span>
                           <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">],</span>
                           <span class="p">[</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_angle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">=</span> <span class="n">current_angle</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_angle</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">rotate_angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span>
        <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="n">rotate_angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>  <span class="c1"># rotation matrix</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_x</span>
        <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="n">coords</span>
        <span class="c1"># save position of mirror</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span><span class="p">,</span> <span class="n">current_z</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_normal_vector_to_mirror</span><span class="p">()</span>  <span class="c1"># add normal vector describing the plane of mirror</span>
        <span class="c1"># calculate beam angle</span>
        <span class="k">return</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span>

    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">plot_type</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_obj</span><span class="p">(</span><span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plot_type</span> <span class="o">==</span> <span class="s1">&#39;3d&#39;</span> <span class="ow">and</span> <span class="n">plot</span><span class="p">:</span>
            <span class="c1"># X, Y = np.meshgrid(self.coordinates[:, 0], self.coordinates[:, 1])</span>
            <span class="c1"># Z = np.repeat([self.coordinates[:, 2]], X.shape[1], axis=0)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">verts</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))]</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">add_collection3d</span><span class="p">(</span><span class="n">Poly3DCollection</span><span class="p">(</span><span class="n">verts</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span>

    <span class="k">def</span> <span class="nf">interact_with_obj_vectorized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rays</span><span class="p">):</span>
        <span class="n">plane_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span>
        <span class="n">plane_normal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal_vector</span>
        <span class="c1"># calculate ray direction vector</span>
        <span class="n">ray_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">anglesXY</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">rays</span><span class="o">.</span><span class="n">anglesXZ</span><span class="p">)</span>
        <span class="n">ray_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">anglesXY</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">rays</span><span class="o">.</span><span class="n">anglesXZ</span><span class="p">)</span>
        <span class="n">ray_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">rays</span><span class="o">.</span><span class="n">anglesXZ</span><span class="p">)</span>

        <span class="c1"># ray_direction = np.array([ray_x, ray_y, ray_z]</span>
        <span class="n">ray_direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ray_x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">ray_direction</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ray_x</span>
        <span class="n">ray_direction</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ray_y</span>
        <span class="n">ray_direction</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ray_z</span>
        <span class="n">rays_point</span> <span class="o">=</span> <span class="n">rays</span><span class="o">.</span><span class="n">positions</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">line_plane_collision_vectorized</span><span class="p">(</span><span class="n">plane_normal</span><span class="p">,</span> <span class="n">plane_point</span><span class="p">,</span> <span class="n">ray_direction</span><span class="p">,</span> <span class="n">rays_point</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">rays</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">settings</span><span class="o">.</span><span class="n">screen_show_behind</span><span class="p">:</span>
            <span class="n">rays</span><span class="o">.</span><span class="n">trace_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">trace_points</span><span class="p">,</span> <span class="p">[</span><span class="n">rays</span><span class="o">.</span><span class="n">positions</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">rays</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">rays</span><span class="o">.</span><span class="n">positions</span> <span class="o">+</span> <span class="n">ray_direction</span> <span class="o">*</span> <span class="mi">100</span>
        <span class="k">return</span> <span class="n">mask</span>

    <span class="k">def</span> <span class="nf">plot_cross_section_on_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">):</span>
        <span class="c1"># screen = pat.Rectangle((-self.diameter / 2, -self.height / 2), self.diameter, self.height,</span>
        <span class="c1">#                        color=(0.1, 0.1, 0.9, 0.3))</span>
        <span class="n">half_of_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">delta_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="n">settings</span><span class="o">.</span><span class="n">no_of_pixels</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">settings</span><span class="o">.</span><span class="n">no_of_pixels</span><span class="p">):</span>
            <span class="n">screen</span> <span class="o">=</span> <span class="n">pat</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">i</span> <span class="o">*</span> <span class="n">delta_x</span> <span class="o">-</span> <span class="n">half_of_x</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">delta_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">,</span>
                                   <span class="n">color</span><span class="o">=</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">screen</span><span class="p">)</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">10</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ymin</span><span class="o">=-</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="n">xmax</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">((</span><span class="o">-</span><span class="n">xmax</span><span class="p">,</span> <span class="n">xmax</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ax</span>

    <span class="k">def</span> <span class="nf">load_spectrum_characteristic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">path</span> <span class="o">==</span> <span class="s2">&quot;default&quot;</span><span class="p">:</span>
            <span class="n">char_data</span> <span class="o">=</span> <span class="n">interpol</span><span class="o">.</span><span class="n">read_characteristics</span><span class="p">(</span><span class="n">settings</span><span class="o">.</span><span class="n">default_path_screen_char</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">char_data</span> <span class="o">=</span> <span class="n">interpol</span><span class="o">.</span><span class="n">read_characteristics</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tran_char_interp</span> <span class="o">=</span> <span class="n">interpol</span><span class="o">.</span><span class="n">linear_interpolation</span><span class="p">(</span><span class="n">char_data</span><span class="p">,</span> <span class="n">part_to_extrapolate</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>


<div class="viewcode-block" id="Prism"><a class="viewcode-back" href="../transmission_line_obj.html#transmission_line_obj.Prism">[docs]</a><span class="k">class</span> <span class="nc">Prism</span><span class="p">(</span><span class="n">TransmissionObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prism:</span>
<span class="sd">        -construction_angle - prism contruction angle in radians</span>

<span class="sd">        -construction_angle_deg - prism contruction angle in degrees</span>

<span class="sd">        -relative_angle - in default is perpendicular, can be rotated, in radians</span>

<span class="sd">        -relative_angle_deg - relative rotation in degrees</span>

<span class="sd">        -thickness - Z axis thickness</span>

<span class="sd">        -length - length of one side, the first attack side</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">construction_angle_deg</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">construction_angle</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">relative_angle_deg</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">relative_angle</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">thickness</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="s2">&quot;Prism&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thickness</span> <span class="o">=</span> <span class="n">thickness</span>
        <span class="c1"># self.refractive_index = self.refractive_index</span>
        <span class="k">if</span> <span class="n">relative_angle_deg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relative_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">relative_angle_deg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relative_angle</span> <span class="o">=</span> <span class="n">relative_angle</span>

        <span class="k">if</span> <span class="n">construction_angle_deg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">construction_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">construction_angle_deg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">construction_angle</span> <span class="o">=</span> <span class="n">construction_angle</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">first_normal_vector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snv_angle</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">float</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">second_side_angle</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">float</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">second_normal_vector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">refractive_index</span><span class="p">(</span><span class="n">wavelenght</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mf">4.45813734</span> <span class="o">*</span> <span class="n">wavelenght</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">wavelenght</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">0.200859853</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span>
                       <span class="p">(</span><span class="mf">0.467216334</span> <span class="o">*</span> <span class="n">wavelenght</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">wavelenght</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">0.391371166</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span>
                       <span class="p">(</span><span class="mf">2.8956629</span> <span class="o">*</span> <span class="n">wavelenght</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">wavelenght</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">47.1362108</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">construct_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span><span class="p">,</span> <span class="n">current_z</span><span class="p">):</span>
        <span class="n">wavelength</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">wav_avg</span>
        <span class="c1"># wavelength = 10</span>
        <span class="n">side_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">construction_angle</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;Prism coordinates&quot;&quot;&quot;</span>
        <span class="c1"># prism is rotated in such way that when angle_to_beam is 0 and beam is parallel to X axis than the first side</span>
        <span class="c1"># is parallel to X axis and zero is in the middle of first side</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                           <span class="p">[</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                           <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">construction_angle</span><span class="p">)</span> <span class="o">*</span> <span class="n">side_length</span><span class="p">,</span>
                            <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">construction_angle</span><span class="p">)</span> <span class="o">*</span> <span class="n">side_length</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">current_angle</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_angle</span>
        <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>  <span class="c1"># rotation matrix</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_x</span>
        <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="n">coords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span><span class="p">,</span> <span class="n">current_z</span><span class="p">])</span>
        <span class="c1"># second_side_angle is pi - position angle of second side of prism</span>
        <span class="n">second_side_angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">construction_angle</span>
        <span class="c1"># second_side_angle = math.atan2(coords[0][1] - coords[2][1], coords[0][0] - coords[2][0])</span>
        <span class="k">if</span> <span class="n">second_side_angle</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">second_side_angle</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="sd">&quot;&quot;&quot;Prism normal vectors&quot;&quot;&quot;</span>
        <span class="n">x_component</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">current_angle</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_angle</span><span class="p">)</span>
        <span class="n">y_component</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">current_angle</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_angle</span><span class="p">)</span>
        <span class="c1"># x_component = np.cos(self.angle - np.pi / 2)</span>
        <span class="c1"># y_component = np.sin(self.angle - np.pi / 2)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_normal_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_component</span><span class="p">,</span> <span class="n">y_component</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># second normal vector</span>
        <span class="n">s_n_v_angle</span> <span class="o">=</span> <span class="n">second_side_angle</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snv_angle</span> <span class="o">=</span> <span class="n">s_n_v_angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">second_side_angle</span> <span class="o">=</span> <span class="n">second_side_angle</span>

        <span class="n">x_component</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">s_n_v_angle</span><span class="p">)</span>
        <span class="n">y_component</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">s_n_v_angle</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">second_normal_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_component</span><span class="p">,</span> <span class="n">y_component</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="sd">&quot;&quot;&quot;Deviation angles&quot;&quot;&quot;</span>
        <span class="n">first_deviation_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">Air</span><span class="o">.</span><span class="n">refractive_index</span><span class="p">(</span><span class="n">wavelength</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">relative_angle</span><span class="p">)</span> <span class="o">/</span>
                                          <span class="n">PrismZnSe</span><span class="o">.</span><span class="n">refractive_index</span><span class="p">(</span><span class="n">wavelength</span><span class="p">))</span>
        <span class="c1"># second angle would be equal to construction_angle - first_angle</span>
        <span class="n">second_attack_angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">construction_angle</span> <span class="o">-</span> <span class="n">first_deviation_angle</span>
        <span class="sd">&quot;&quot;&quot;Internal collisions&quot;&quot;&quot;</span>
        <span class="n">first_internal_ray_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">+</span> <span class="n">first_deviation_angle</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
                                              <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">+</span> <span class="n">first_deviation_angle</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">])</span>

        <span class="n">plane_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">plane_normal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_normal_vector</span>
        <span class="c1"># calculate ray direction vector</span>
        <span class="n">ray_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span><span class="p">,</span> <span class="n">current_z</span><span class="p">])</span>

        <span class="n">intersection_point</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">line_plane_collision</span><span class="p">(</span><span class="n">plane_normal</span><span class="p">,</span> <span class="n">plane_point</span><span class="p">,</span> <span class="n">first_internal_ray_vector</span><span class="p">,</span> <span class="n">ray_point</span><span class="p">)</span>
        <span class="c1"># length = np.linalg.norm(c - a)</span>
        <span class="n">second_deviation_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">PrismZnSe</span><span class="o">.</span><span class="n">refractive_index</span><span class="p">(</span><span class="n">wavelength</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">second_attack_angle</span><span class="p">)</span> <span class="o">/</span>
                                           <span class="n">Air</span><span class="o">.</span><span class="n">refractive_index</span><span class="p">(</span><span class="n">wavelength</span><span class="p">))</span>
        <span class="c1"># print(((np.pi - second_side_angle+current_angle - 2*np.pi) - (np.pi/2 - second_deviation_angle) )*180/np.pi)</span>
        <span class="c1"># print((current_angle - s_n_v_angle + second_deviation_angle) * 180 / np.pi)</span>
        <span class="c1"># current_angle = np.pi/2 - second_deviation_angle + second_side_angle</span>
        <span class="n">current_angle</span> <span class="o">=</span> <span class="n">s_n_v_angle</span> <span class="o">-</span> <span class="n">second_deviation_angle</span>
        <span class="n">current_x</span> <span class="o">=</span> <span class="n">intersection_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">current_y</span> <span class="o">=</span> <span class="n">intersection_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span>

    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">plot_type</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_obj</span><span class="p">(</span><span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">coords3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">coords3d</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">thickness</span>
        <span class="n">coords3d</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">thickness</span>
        <span class="k">if</span> <span class="n">plot</span> <span class="ow">and</span> <span class="n">plot_type</span> <span class="o">==</span> <span class="s1">&#39;3d&#39;</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot_trisurf</span><span class="p">(</span><span class="n">coords3d</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">coords3d</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">coords3d</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot_trisurf</span><span class="p">(</span><span class="n">coords3d</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">coords3d</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">coords3d</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">current_x</span><span class="p">],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">current_y</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">coords3d</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span>

    <span class="k">def</span> <span class="nf">interact_with_obj_vectorized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rays</span><span class="p">):</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">p3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">min_angle</span><span class="p">,</span> <span class="n">max_angle</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">calculate_acceptance_angles_vectorized</span><span class="p">(</span>
            <span class="n">rays</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">rays</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p3</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p3</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">fit_in</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">does_fit_in_acceptance_angle_vectorized</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">anglesXY</span><span class="p">,</span> <span class="n">min_angle</span><span class="p">,</span> <span class="n">max_angle</span><span class="p">)</span>
        <span class="c1"># if hit</span>
        <span class="n">plane_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span>
        <span class="n">plane_normal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_normal_vector</span>
        <span class="c1"># calculate ray direction vector</span>
        <span class="n">ray_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">anglesXY</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">rays</span><span class="o">.</span><span class="n">anglesXZ</span><span class="p">)</span>
        <span class="n">ray_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">anglesXY</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">rays</span><span class="o">.</span><span class="n">anglesXZ</span><span class="p">)</span>
        <span class="n">ray_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">rays</span><span class="o">.</span><span class="n">anglesXZ</span><span class="p">)</span>
        <span class="c1"># ray_x = np.cos(np.full((len(rays.anglesXY)), 2.094395102393195))</span>
        <span class="c1"># ray_y = np.sin(np.full((len(rays.anglesXY)), 2.094395102393195))</span>
        <span class="c1"># ray_z = 0</span>
        <span class="c1"># ray_direction = np.array([ray_x, ray_y, ray_z]</span>
        <span class="n">ray_direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ray_x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">ray_direction</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ray_x</span>
        <span class="n">ray_direction</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ray_y</span>
        <span class="n">ray_direction</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ray_z</span>

        <span class="c1"># calculate intersection point</span>
        <span class="sd">&quot;&quot;&quot;In future can be checked if inside the mirror, just to be sure xD&quot;&quot;&quot;</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">line_plane_collision_vectorized</span><span class="p">(</span>
            <span class="n">plane_normal</span><span class="p">,</span> <span class="n">plane_point</span><span class="p">,</span> <span class="n">ray_direction</span><span class="p">,</span> <span class="n">rays</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span>

        <span class="c1"># check if fit in mirror with diameter</span>
        <span class="n">is_in_plane</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span>
                                      <span class="n">rays</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                                      <span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                                                  <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])))</span> <span class="o">&amp;</span>
                       <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span>
                                      <span class="n">rays</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                                      <span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">positions</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                                                                   <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])))</span>
        <span class="n">first_angle_of_attack_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">is_in_plane</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">first_angle_of_attack_xy</span><span class="p">[</span><span class="n">is_in_plane</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tools</span><span class="o">.</span><span class="n">angle_between</span><span class="p">(</span><span class="n">ray_direction</span><span class="p">[</span><span class="n">is_in_plane</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span>
                                                                             <span class="n">plane_normal</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span>
                                                                             <span class="n">already_unit_vector</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="c1"># first_angle_of_attack_xy[first_angle_of_attack_xy &gt; np.pi / 4] = \</span>
        <span class="c1">#     np.pi / 2 - first_angle_of_attack_xy[first_angle_of_attack_xy &gt; np.pi / 4]</span>

        <span class="n">first_angle_of_attack_xz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">anglesXZ</span><span class="p">)</span>
        <span class="n">first_deviation_angle_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">Air</span><span class="o">.</span><span class="n">refractive_index</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">)</span> <span class="o">*</span>
                                             <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">first_angle_of_attack_xy</span><span class="p">)</span> <span class="o">/</span>
                                             <span class="n">PrismZnSe</span><span class="o">.</span><span class="n">refractive_index</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">))</span>
        <span class="c1"># first_deviation_angle_xy[first_deviation_angle_xy &gt; np.pi/4] = \</span>
        <span class="c1">#     np.pi/2 - first_deviation_angle_xy[first_deviation_angle_xy &gt; np.pi/4]</span>
        <span class="n">first_deviation_angle_xz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">Air</span><span class="o">.</span><span class="n">refractive_index</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">)</span> <span class="o">*</span>
                                             <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">first_angle_of_attack_xz</span><span class="p">)</span> <span class="o">/</span>
                                             <span class="n">PrismZnSe</span><span class="o">.</span><span class="n">refractive_index</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">))</span>

        <span class="c1"># second angle would be equal to construction_angle - first_angle</span>
        <span class="n">second_attack_angle_xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">construction_angle</span> <span class="o">-</span> <span class="n">first_deviation_angle_xy</span>
        <span class="c1"># second_attack_angle_xy[second_attack_angle_xy &gt; np.pi/4] = \</span>
        <span class="c1">#     np.pi/2 - second_attack_angle_xy[second_attack_angle_xy &gt; np.pi/4]</span>
        <span class="n">second_attack_angle_xz</span> <span class="o">=</span> <span class="n">first_deviation_angle_xz</span>
        <span class="n">second_attack_angle_xz</span><span class="p">[</span><span class="n">second_attack_angle_xz</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="sd">&quot;&quot;&quot;Internal collisions&quot;&quot;&quot;</span>

        <span class="n">ray_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">+</span> <span class="n">first_deviation_angle_xy</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span>
                                                                                   <span class="n">first_deviation_angle_xz</span><span class="p">)</span>
        <span class="n">ray_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">+</span> <span class="n">first_deviation_angle_xy</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span>
                                                                                   <span class="n">first_deviation_angle_xz</span><span class="p">)</span>
        <span class="n">ray_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">first_deviation_angle_xz</span><span class="p">)</span>

        <span class="n">first_internal_ray_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">ray_x</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">first_internal_ray_vector</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ray_x</span>
        <span class="n">first_internal_ray_vector</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ray_y</span>
        <span class="n">first_internal_ray_vector</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ray_z</span>
        <span class="n">plane_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">plane_normal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_normal_vector</span>
        <span class="c1"># calculate ray direction vector</span>

        <span class="n">intersection_points</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">line_plane_collision_vectorized</span><span class="p">(</span><span class="n">plane_normal</span><span class="p">,</span> <span class="n">plane_point</span><span class="p">,</span>
                                                                    <span class="n">first_internal_ray_vector</span><span class="p">,</span> <span class="n">rays</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span>
        <span class="c1"># length = np.linalg.norm(c - a)</span>
        <span class="n">second_deviation_angle_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">PrismZnSe</span><span class="o">.</span><span class="n">refractive_index</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">)</span> <span class="o">*</span>
                                              <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">second_attack_angle_xy</span><span class="p">)</span> <span class="o">/</span>
                                              <span class="n">Air</span><span class="o">.</span><span class="n">refractive_index</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">))</span>
        <span class="n">second_deviation_angle_xz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">PrismZnSe</span><span class="o">.</span><span class="n">refractive_index</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">)</span> <span class="o">*</span>
                                              <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">second_attack_angle_xz</span><span class="p">)</span> <span class="o">/</span>
                                              <span class="n">Air</span><span class="o">.</span><span class="n">refractive_index</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">))</span>
        <span class="c1"># print(np.rad2deg(first_angle_of_attack_xy))</span>
        <span class="c1"># print(np.rad2deg(tools.angle_between(ray_direction, self.first_normal_vector)))</span>

        <span class="n">rays</span><span class="o">.</span><span class="n">anglesXY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snv_angle</span> <span class="o">-</span> <span class="n">second_deviation_angle_xy</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">anglesXZ</span> <span class="o">=</span> <span class="n">second_deviation_angle_xz</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">trace_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">trace_points</span><span class="p">,</span> <span class="p">[</span><span class="n">rays</span><span class="o">.</span><span class="n">positions</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># print(&quot;Prism av path: &quot;, np.mean(np.sqrt(np.sum((rays.positions-intersection_points)**2, axis=1))))</span>

        <span class="n">rays</span><span class="o">.</span><span class="n">trace_length_in_other</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">rays</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">intersection_points</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">intersection_points</span>

        <span class="c1"># ray.angleXY, ray.angleXZ = tools.get_xyxzangles_from_vector(reflected_vector)</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">anglesXY</span><span class="p">[</span><span class="n">rays</span><span class="o">.</span><span class="n">anglesXY</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">anglesXZ</span><span class="p">[</span><span class="n">rays</span><span class="o">.</span><span class="n">anglesXZ</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="c1"># print(second_attack_angle_xz)</span>
        <span class="c1"># self.angleXZ = self.angleXZ</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">fit_in</span><span class="p">,</span> <span class="n">is_in_plane</span><span class="p">)</span></div>


<div class="viewcode-block" id="PrismZnSe"><a class="viewcode-back" href="../transmission_line_obj.html#transmission_line_obj.PrismZnSe">[docs]</a><span class="k">class</span> <span class="nc">PrismZnSe</span><span class="p">(</span><span class="n">Prism</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prism Zinc Selenide:</span>
<span class="sd">            From Prism it&#39;s different with refractive index and spectrum transformation</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">load_spectrum_characteristic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">path</span> <span class="o">==</span> <span class="s2">&quot;default&quot;</span><span class="p">:</span>
            <span class="n">char_data</span> <span class="o">=</span> <span class="n">interpol</span><span class="o">.</span><span class="n">read_characteristics</span><span class="p">(</span><span class="n">settings</span><span class="o">.</span><span class="n">default_path_prism_zn_se_char</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">char_data</span> <span class="o">=</span> <span class="n">interpol</span><span class="o">.</span><span class="n">read_characteristics</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tran_char_interp</span> <span class="o">=</span> <span class="n">interpol</span><span class="o">.</span><span class="n">linear_interpolation</span><span class="p">(</span><span class="n">char_data</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">refractive_index</span><span class="p">(</span><span class="n">wavelenght</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mf">4.45813734</span> <span class="o">*</span> <span class="n">wavelenght</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">wavelenght</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">0.200859853</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span>
                       <span class="p">(</span><span class="mf">0.467216334</span> <span class="o">*</span> <span class="n">wavelenght</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">wavelenght</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">0.391371166</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span>
                       <span class="p">(</span><span class="mf">2.8956629</span> <span class="o">*</span> <span class="n">wavelenght</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">wavelenght</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">47.1362108</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">Window</span><span class="p">(</span><span class="n">TransmissionObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Window - vacuum chamber viewport:</span>
<span class="sd">            The most important here is transform characteristics, if needed can be changed to act like a prism, to take</span>
<span class="sd">            into consideration the dispersion, but it is usually perpendicular, so it doesn&#39;t change much</span>

<span class="sd">            -relative angle - defined in radians, window in default is set perpendicular to beam, but can be rotated</span>

<span class="sd">            -relative_angle_deg - allows for setting angles in degrees</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">relative_angle_deg</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">relative_angle</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="s2">&quot;Window&quot;</span>
        <span class="k">if</span> <span class="n">relative_angle_deg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relative_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">relative_angle_deg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relative_angle</span> <span class="o">=</span> <span class="n">relative_angle</span>


    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">plot_type</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># construct rectangle without rotation, z coordinate - 0</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                           <span class="p">[</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                           <span class="p">[</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                           <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>

        <span class="c1"># rotate_angle = actual_angle + obj.angle/2      # if the angle is relative to the beam</span>
        <span class="n">rotate_angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span>  <span class="c1"># if the angle is absolute</span>
        <span class="c1"># firstly translate the center of rotation</span>
        <span class="c1"># coords[:, 0] -= current_x</span>
        <span class="c1"># coords[:, 1] -= current_y</span>
        <span class="k">if</span> <span class="n">plot_type</span> <span class="o">==</span> <span class="s1">&#39;3d&#39;</span> <span class="ow">and</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">num_of_points</span> <span class="o">=</span> <span class="mi">20</span>
            <span class="n">coords3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_of_points</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">3</span><span class="p">])</span>
            <span class="c1"># create points in z dimension</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">angle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">num_of_points</span><span class="p">)):</span>
                <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="n">angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>  <span class="c1"># rotation matrix</span>
                <span class="n">coords3d</span><span class="p">[</span><span class="n">index</span> <span class="o">*</span> <span class="mi">4</span><span class="p">:</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
            <span class="n">coords3d</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">=</span> <span class="n">coords3d</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
            <span class="c1"># rotate along z axis</span>
            <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="n">rotate_angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>  <span class="c1"># rotation matrix</span>
            <span class="n">coords3d</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">coords3d</span><span class="p">)</span>
            <span class="c1"># translate back to the location</span>
            <span class="n">coords3d</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_x</span>
            <span class="n">coords3d</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_y</span>

            <span class="n">bottom</span> <span class="o">=</span> <span class="n">coords3d</span><span class="p">[</span><span class="n">coords3d</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">coords3d</span><span class="p">[</span><span class="n">coords3d</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">plot_trisurf</span><span class="p">(</span><span class="n">bottom</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">bottom</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">bottom</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;yellow&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot_trisurf</span><span class="p">(</span><span class="n">top</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">top</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">top</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;yellow&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="n">rotate_angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>  <span class="c1"># rotation matrix</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
            <span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_x</span>
            <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_y</span>
            <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;g&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span>

    <span class="k">def</span> <span class="nf">construct_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span><span class="p">,</span> <span class="n">current_z</span><span class="p">):</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                           <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                           <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                           <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_angle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">=</span> <span class="n">current_angle</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_angle</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">rotate_angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span>
        <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="n">rotate_angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>  <span class="c1"># rotation matrix</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_x</span>
        <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="n">coords</span>
        <span class="c1"># save position of mirror</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span><span class="p">,</span> <span class="n">current_z</span><span class="p">])</span>
        <span class="c1"># calculate beam angle</span>
        <span class="c1"># current_angle = np.pi - current_angle - 2 * self.angle</span>
        <span class="k">return</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span>

    <span class="k">def</span> <span class="nf">load_spectrum_characteristic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">path</span> <span class="o">==</span> <span class="s2">&quot;default&quot;</span><span class="p">:</span>
            <span class="n">char_data</span> <span class="o">=</span> <span class="n">interpol</span><span class="o">.</span><span class="n">read_characteristics</span><span class="p">(</span><span class="n">settings</span><span class="o">.</span><span class="n">default_path_window_char</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">char_data</span> <span class="o">=</span> <span class="n">interpol</span><span class="o">.</span><span class="n">read_characteristics</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tran_char_interp</span> <span class="o">=</span> <span class="n">interpol</span><span class="o">.</span><span class="n">linear_interpolation</span><span class="p">(</span><span class="n">char_data</span><span class="p">,</span> <span class="n">part_to_extrapolate</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">interact_with_obj_vectorized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rays</span><span class="p">):</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">trace_length_in_other</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>


<div class="viewcode-block" id="ParabolicMirror"><a class="viewcode-back" href="../transmission_line_obj.html#transmission_line_obj.ParabolicMirror">[docs]</a><span class="k">class</span> <span class="nc">ParabolicMirror</span><span class="p">(</span><span class="n">TransmissionObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parabolic Mirrors:</span>
<span class="sd">            needs reflected focal length, and parent focal length,</span>
<span class="sd">            -rfl - reflected focal length</span>

<span class="sd">            -pfl - parent focal length</span>

<span class="sd">            -relative_angle - can rotate component according to beam, in default its placed 90 degrees to the beam</span>
<span class="sd">            relative angle is added to this angle, takes angle in radians</span>

<span class="sd">            -relative_angle_deg - allows for giving value in degrees</span>

<span class="sd">            -mirrored - is a flag which rotates the component by 180 degrees, to be able to easy component placement</span>
<span class="sd">            according to its role, when True it will collimate beam if starting in focus point, when False it will focus beam,</span>
<span class="sd">            In 2D view of line the dot on the end of parabola is the higher value mirror end, where parabola, has higher value.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">relative_angle_deg</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">relative_angle</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">rfl</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">pfl</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">mirrored</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="s2">&quot;ParabolicMirror&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rfl</span> <span class="o">=</span> <span class="n">rfl</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pfl</span> <span class="o">=</span> <span class="n">pfl</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mirrored</span> <span class="o">=</span> <span class="n">mirrored</span>
        <span class="k">if</span> <span class="n">relative_angle_deg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relative_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">relative_angle_deg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relative_angle</span> <span class="o">=</span> <span class="n">relative_angle</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mirror_surface</span><span class="p">:</span> <span class="n">callable</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">add_normal_vector_to_mirror</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">dxy</span><span class="p">,</span> <span class="n">dxz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">rfl</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">refle_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">dxy</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">x_component</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">refle_angle</span><span class="p">)</span>
        <span class="n">y_component</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">refle_angle</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normal_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_component</span><span class="p">,</span> <span class="n">y_component</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">construct_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span><span class="p">,</span> <span class="n">current_z</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_angle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">=</span> <span class="o">-</span><span class="n">current_angle</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_angle</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">=</span> <span class="o">-</span><span class="n">current_angle</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mirrored</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="n">coords</span><span class="p">,</span> <span class="n">mirror_surface</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_paraboloid</span><span class="p">()</span>
        <span class="c1"># mirror surface is in zero angle</span>
        <span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_x</span>
        <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">current_y</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">coords</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]]),</span> <span class="n">coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mirror_surface</span> <span class="o">=</span> <span class="n">mirror_surface</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parabola_center</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_normal_vector_to_mirror</span><span class="p">()</span>

        <span class="n">direction_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">current_angle</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">current_angle</span><span class="p">),</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">reflected_vector</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">reflect_vector_from_plane</span><span class="p">(</span><span class="n">direction_vector</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal_vector</span><span class="p">)</span>
        <span class="n">current_angle</span><span class="p">,</span> <span class="n">xz</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">get_xyxzangles_from_vector</span><span class="p">(</span><span class="n">reflected_vector</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span>

    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">plot_type</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">plot_type</span> <span class="o">==</span> <span class="s1">&#39;3d&#39;</span> <span class="ow">and</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mirror_x_domain</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mirror_x_domain</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">10</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
            <span class="n">xv</span><span class="p">,</span> <span class="n">zv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
            <span class="n">x_flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)))</span>
            <span class="n">z_flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">zv</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)))</span>
            <span class="n">y_flat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mirror_surface</span><span class="p">(</span><span class="n">x_flat</span><span class="p">,</span> <span class="n">z_flat</span><span class="p">)</span>
            <span class="n">x_flat</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rfl</span>
            <span class="n">y_flat</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mirror_surface</span><span class="p">(</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rfl</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_flat</span><span class="p">)))</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_flat</span><span class="p">,</span> <span class="n">y_flat</span><span class="p">,</span> <span class="n">z_flat</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="n">points</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span>

            <span class="n">bottom</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">z_flat</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">z_flat</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
            <span class="c1"># coords3d = np.reshape(coords3d[:, 2], (len(x), len(y)))</span>
            <span class="c1"># ax.plot_surface(xv, yv, coords3d)</span>
            <span class="c1"># print()</span>
            <span class="c1"># ax.plot_trisurf(x_flat, coords3d, z_flat, linewidth=0, color=&quot;green&quot;)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot_trisurf</span><span class="p">(</span><span class="n">bottom</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">bottom</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">bottom</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot_trisurf</span><span class="p">(</span><span class="n">top</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">top</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">top</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span>
            <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;g&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="n">direction_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">current_angle</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">current_angle</span><span class="p">),</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">reflected_vector</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">reflect_vector_from_plane</span><span class="p">(</span><span class="n">direction_vector</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal_vector</span><span class="p">)</span>
        <span class="n">current_angle</span><span class="p">,</span> <span class="n">xz</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">get_xyxzangles_from_vector</span><span class="p">(</span><span class="n">reflected_vector</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">current_angle</span><span class="p">,</span> <span class="n">current_x</span><span class="p">,</span> <span class="n">current_y</span>

<div class="viewcode-block" id="ParabolicMirror.make_paraboloid"><a class="viewcode-back" href="../transmission_line_obj.html#transmission_line_obj.ParabolicMirror.make_paraboloid">[docs]</a>    <span class="k">def</span> <span class="nf">make_paraboloid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs paraboloid, calculates the parabola coefficient, makes domains, where the mirror is defined in</span>
<span class="sd">        paraboloid coordinate system, have some unused stuff, which can be used later.</span>
<span class="sd">        :return: (np.array, callable) coords, paraboloid_value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parabola_coeff</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">construct_parabola_from_lengths</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rfl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pfl</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parabola_coeff</span> <span class="o">=</span> <span class="n">parabola_coeff</span>

        <span class="k">def</span> <span class="nf">paraboloid_value</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
            <span class="c1"># don&#39;t rotate the parabola, because it should be centered</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">z</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">parabola_coeff</span>

        <span class="c1"># values of cutout of parabola</span>
        <span class="n">center_mirror_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">parabola_coeff</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rfl</span><span class="p">)</span>  <span class="c1"># derivative in center</span>
        <span class="n">x_radius</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">center_mirror_angle</span><span class="p">)</span>
        <span class="n">x_minimal_range</span> <span class="o">=</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rfl</span> <span class="o">-</span> <span class="n">x_radius</span>
        <span class="n">x_maximal_range</span> <span class="o">=</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rfl</span> <span class="o">+</span> <span class="n">x_radius</span>
        <span class="c1"># x_minimal_range = - self.rfl - self.diameter / 2</span>
        <span class="c1"># x_maximal_range = - self.rfl + self.diameter / 2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mirror_x_domain</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_minimal_range</span><span class="p">,</span> <span class="n">x_maximal_range</span><span class="p">]</span>
        <span class="n">x_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x_minimal_range</span><span class="p">,</span> <span class="n">x_maximal_range</span><span class="p">,</span> <span class="n">settings</span><span class="o">.</span><span class="n">no_of_parabola_surf_points</span><span class="p">)</span>
        <span class="n">y_vals</span> <span class="o">=</span> <span class="n">paraboloid_value</span><span class="p">(</span><span class="n">x_vals</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mirror_y_domain</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">y_vals</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">y_vals</span><span class="p">)]</span>
        <span class="c1"># rotate with the center of cutout, with axis perpendicular to the cutout</span>

        <span class="n">x_vals</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rfl</span>

        <span class="n">y_vals</span> <span class="o">-=</span> <span class="n">paraboloid_value</span><span class="p">(</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rfl</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_vals</span><span class="p">)))</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_vals</span><span class="p">,</span> <span class="n">y_vals</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x_vals</span><span class="p">)))])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="c1"># rotate to the current angle</span>
        <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="c1"># mirror_surface = rotation_matrix.apply(mirror_surface)</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parabola_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">rfl</span><span class="p">,</span>
                                         <span class="o">-</span><span class="n">paraboloid_value</span><span class="p">(</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rfl</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                         <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parabola_center</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parabola_center</span><span class="p">)</span>

        <span class="c1"># if self.mirrored:</span>
        <span class="c1">#     mirroring_rot = R.from_rotvec(np.pi/2 * np.array([0, 0, 1]))</span>
        <span class="c1">#     coords = mirroring_rot.apply(coords)</span>
        <span class="c1">#     self.parabola_center = mirroring_rot.apply(self.parabola_center)</span>

        <span class="k">def</span> <span class="nf">rotated_paraboloid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rfl</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">paraboloid_value</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">paraboloid_value</span><span class="p">(</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rfl</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="c1"># if self.mirrored:</span>
            <span class="c1">#     mirroring_rot = R.from_rotvec(np.pi * np.array([0, 1, 0]))</span>
            <span class="c1">#     rotated = mirroring_rot.apply(np.array([x, y, z]).transpose())</span>
            <span class="c1"># else:</span>
            <span class="n">rotated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="n">rotated</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">rotated</span><span class="p">)</span>
            <span class="n">rotated</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rfl</span>
            <span class="n">rotated</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">paraboloid_value</span><span class="p">(</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rfl</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rotated</span>

        <span class="k">def</span> <span class="nf">derivative_of_paraboloid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
            <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">parabola_coeff</span>
            <span class="n">xz</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">z</span><span class="p">)</span> <span class="o">*</span> <span class="n">parabola_coeff</span>
            <span class="k">return</span> <span class="n">xy</span><span class="p">,</span> <span class="n">xz</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">derivative</span> <span class="o">=</span> <span class="n">derivative_of_paraboloid</span>
        <span class="k">return</span> <span class="n">coords</span><span class="p">,</span> <span class="n">paraboloid_value</span></div>

    <span class="k">def</span> <span class="nf">interact_with_obj_vectorized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rays</span><span class="p">):</span>
        <span class="c1"># rotation of all rays to the right position according to mirror</span>
        <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="n">starting_points</span> <span class="o">=</span> <span class="n">rays</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">parabola_center</span>
        <span class="n">starting_points</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">starting_points</span><span class="p">)</span>

        <span class="n">directions</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">get_direction_vector_from_two_angles</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">anglesXY</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle</span><span class="p">,</span> <span class="n">rays</span><span class="o">.</span><span class="n">anglesXZ</span><span class="p">)</span>
        <span class="c1"># find intersections and normal vectors in them on parabola</span>
        <span class="n">intersections</span><span class="p">,</span> <span class="n">normal_vectors</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">line_intersection_with_paraboloid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parabola_coeff</span><span class="p">,</span>
                                                                                <span class="n">starting_points</span><span class="p">,</span>
                                                                                <span class="n">directions</span><span class="p">,</span>
                                                                                <span class="bp">self</span><span class="o">.</span><span class="n">mirror_x_domain</span><span class="p">,</span>
                                                                                <span class="bp">self</span><span class="o">.</span><span class="n">mirror_y_domain</span><span class="p">)</span>
        <span class="c1"># reverse rotation and transition of rays</span>
        <span class="c1"># rotation_matrix =</span>
        <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">from_rotvec</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="n">intersections</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">intersections</span><span class="p">)</span>
        <span class="n">intersections</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parabola_center</span>
        <span class="c1"># reflect rays from planes on paraboloid</span>
        <span class="n">reflected_vectors</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">reflect_many_vectors_from_many_planes</span><span class="p">(</span><span class="n">directions</span><span class="p">,</span> <span class="n">normal_vectors</span><span class="p">)</span>
        <span class="n">reflected_vectors</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">reflected_vectors</span><span class="p">)</span>
        <span class="c1"># calculate angles from direction vector</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">anglesXY</span><span class="p">,</span> <span class="n">rays</span><span class="o">.</span><span class="n">anglesXZ</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">get_xyxzangles_from_vectors</span><span class="p">(</span><span class="n">reflected_vectors</span><span class="p">)</span>
        <span class="c1"># if self.mirrored:</span>
        <span class="c1">#     rays.anglesXY = np.zeros((len(rays.anglesXY))) - self.angle + np.pi/2</span>
        <span class="c1">#     rays.anglesXZ = np.zeros((len(rays.anglesXY)))</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">anglesXY</span><span class="p">[</span><span class="n">rays</span><span class="o">.</span><span class="n">anglesXY</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">intersections</span>
        <span class="c1"># print(intersections)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">rays</span><span class="o">.</span><span class="n">positions</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">load_spectrum_characteristic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">path</span> <span class="o">==</span> <span class="s2">&quot;default&quot;</span><span class="p">:</span>
            <span class="n">char_data</span> <span class="o">=</span> <span class="n">interpol</span><span class="o">.</span><span class="n">read_characteristics</span><span class="p">(</span><span class="n">settings</span><span class="o">.</span><span class="n">default_path_parabolic_mirror_char</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">char_data</span> <span class="o">=</span> <span class="n">interpol</span><span class="o">.</span><span class="n">read_characteristics</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="c1"># char_data = interpol.normalize_characteristics(char_data, shift_maximum=0.5)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tran_char_interp</span> <span class="o">=</span> <span class="n">interpol</span><span class="o">.</span><span class="n">linear_interpolation</span><span class="p">(</span><span class="n">char_data</span><span class="p">)</span></div>


<div class="viewcode-block" id="Air"><a class="viewcode-back" href="../transmission_line_obj.html#transmission_line_obj.Air">[docs]</a><span class="k">class</span> <span class="nc">Air</span><span class="p">(</span><span class="n">Vacuum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Air component:</span>
<span class="sd">        has unique refractive index function and energies transform, in this function it is just adding its length to total</span>
<span class="sd">        - length of itself to length traveled by rays in atmosphere.</span>

<span class="sd">        Inherits from vacuum methods for drawing and constructing transmission line</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Vacuum</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="s2">&quot;Air&quot;</span>
        <span class="c1"># super().__init__(kwargs)</span>

    <span class="k">def</span> <span class="nf">get_transformation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">total_atmosphere_length</span><span class="p">):</span>
        <span class="n">total_atmosphere_length</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tran_char_interp</span>

    <span class="k">def</span> <span class="nf">transform_energies_vectorized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rays</span><span class="p">):</span>
        <span class="n">rays</span><span class="o">.</span><span class="n">trace_length_in_atmosphere</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">refractive_index</span><span class="p">(</span><span class="n">wavelenght</span><span class="p">):</span>
        <span class="c1"># return 1</span>
        <span class="k">return</span> <span class="mf">0.05792105</span> <span class="o">/</span> <span class="p">(</span><span class="mf">238.0185</span> <span class="o">-</span> <span class="n">wavelenght</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mf">0.00167917</span> <span class="o">/</span> <span class="p">(</span><span class="mf">57.362</span> <span class="o">-</span> <span class="n">wavelenght</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span></div>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Juliusz Stanislaw Tarnowski, Michal Porebski, Natalia Stalmach, Milosz Lepak.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.0.1',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/jquery.fancybox.min.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
  <script type="text/javascript">
    $(function(){
      $('.image-reference').fancybox();
    })
  </script>

</body>
</html>